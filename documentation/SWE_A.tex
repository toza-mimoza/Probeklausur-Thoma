% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.2 for LaTeX2e
%
\documentclass{llncs}

%
%\usepackage{makeidx}  % allows for indexgeneration
%

\usepackage{epsfig}
%\usepackage{multirow}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

\makeatletter
\renewcommand\subsubsection{\@startsection{subsubsection}{2}{\z@}%
                       {-18\p@ \@plus -4\p@ \@minus -4\p@}%
                       {\lineskip}%
                       {\normalfont\normalsize\bfseries\boldmath}}
\makeatother


\title{Software Engeneering Analysis Sientific Report}

 % abbreviated author list (for running head)
\author{Kendra Birringer (1229372) \\ Nader Cacace (1208115) \\ Steffen Hanzlik (1207417) \\ Marco Peluso (1228849) \\ Svetozar Stojanovic (1262287)}
%%% modified list of authors for the TOC (add the affiliations)

\institute{
Frankfurt University of Applied Sciences \\
}

\maketitle              % typeset the title of the contribution
%=============================================================================
\section{Exercise 2}
%=============================================================================
%=============================================================================
\subsection{Fahrzeug }
%=============================================================================

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
void Fahrzeug::setName(const char *n)
{
     if (name != nullptr) {
     	delete name;
     	name = nullptr; // handling dangling pointer to freed memory
     }

     if (n != nullptr) { // handling empty pointer as parameter, preventing strlen from crashing
     	name = new char[strlen(n)+1];
     	strcpy(name, n);
     }
}



Fahrzeug& Fahrzeug::operator=(const Fahrzeug &other) {
	delete[] name;

	if (other.name != nullptr) { // handling empty pointer as parameter, preventing strlen from crashing
		name = new char[strlen(other.name) + 1];
		strcpy(name, other.name);
	}
	return *this;
}

\end{lstlisting}
\scriptsize{Figure 1 Fahrzeug Program}\newline


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%=============================================================================
\section{Exercise 3}
%=============================================================================
%=============================================================================
\subsection{EBook Headerfile}
%=============================================================================

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
#ifndef _EBOOK_H_
#define _EBOOK_H_

#include <string>
#include <iostream>

using namespace std;

class EBook {
private:
	string title, content; 
public:
	EBook();
	EBook(string title, string content);
	void setTitle(string title);
	string getTitle() const;
	void setContent(string content);
	string getContent() const;
	void print() const;
	friend ostream &operator<<(ostream &output, const EBook &book);
};

#endif

\end{lstlisting}
\scriptsize{Figure 2 Header of EBook Program}\newline
\newline
\newline
In the header file the declaration of the private and the public members of the Ebook class takes place.\newline
The private members are two Strings named 'title' and 'content'.
The public members of the class EBook are the default constructor and an overloaded constructor with the parameters title and content.\newline 
Then we also declared the public 'getter' and 'setter' methods. Furthermore we need a print method and we must overload the \&operator$<<$ method.\newline

%\newpage
%=============================================================================
\subsection{Implementation of the Ebook Class}
%=============================================================================
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
#include "eBook.h"
#include <iostream>

using namespace std;

EBook::EBook() : title(""), content("") {};

EBook::EBook(string title, string content) : title(title), content(content) {};

void EBook::setTitle(string title) {
	if (title != "") {
		this->title = title;
	} else {
		cout << "Title not set!" << endl;
	}
}

string EBook::getTitle() const {
	return this->title;
}

void EBook::setContent(string content) {
	if (content != "") {
		this->content = content;
	} else {
		cout << "Content not set!" << endl;
	}
}

string EBook::getContent() const {
	return this->content;
}

void EBook::print() const {
	cout << "Title: " << this->title << '\n';
	cout << "Content: " << this->content << '\n';
}

ostream & operator<<(ostream &output, const EBook &book) {
	book.print();
	return output;
}
\end{lstlisting}
\scriptsize{Figure 3 Implementation of Ebook class}\newline
\newline
In the Ebook.cpp file we implemented the declared methods of Ebook.h.\newline
First we implemented the standard constructor initializing the member variables 'title' and 'content' using an initializer list. \newline
Furthermore we implemented a overloaded constructor Ebook with the arguments 'title' and 'content' and initialized the 'title' and 'content' with the passed arguments 'title' and 'content'.\newline
\newline
Then we implemented the 'getter' and 'setter' methods.(You knnow how they work)\newline
Also we implemented the 'print' method. This method is for printing the 'title' and the 'content' and we overloaded the \&operater$<<$ function.\newline




%=============================================================================
\subsection{Main Class}
%=============================================================================

\begin{lstlisting}
#include <iostream>
#include "eBook.h"

int main() {
	EBook book("Brown Fox", "The quick brown fox jumps over the lazy dog.");
	std::cout << book; 

	return 0; 
}
\end{lstlisting}
\scriptsize{Figure 4 Main class of Ebook program}\newline
\newline
The main method executes the Ebook Class.
%=============================================================================
\section{Exercise 4}
%=============================================================================
%=============================================================================
\subsection{Box Headerfile}
%=============================================================================

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
#ifndef _BOX_H_
#define _BOX_H_

class Box {
private:
	double xMin, xMax, yMin, yMax;
public:
	
	Box();
	double getXMin() const;
	double getXMax() const;
	double getYMin() const;
	double getYMax() const;
	void setXMax(double val);
	void setXMin(double val);
	void setYMin(double val);
	void setYMax(double val);
	friend Box operator+(Box left, Box right);
	void print() const;
};
#endif
\end{lstlisting}
\scriptsize{Figure 5 Header of Box}\newline
\newline
\newline
In the header file the declaration of the private and the public members of the Box class takes place.\newline
The private members are four double named 'xMin', 'xMax', 'yMin' and 'yMax'.
The public members of the class Box are the default constructor.\newline 
Then we also declared the public 'getter' and 'setter' methods. Furthermore we need also a 'print' method and we musted overload the $+operator<<$ method.\newline

%=============================================================================
\subsection{Circle Headerfile}
%=============================================================================
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
#ifndef _CIRCLE_H_
#define _CIRCLE_H_

#include "Form.h"

class Circle : public Form
{
private: 
	double radius; 
public:
	Circle();
	Circle(double rad);
	void move(double dX, double dY);
	void setUpBox();
private:
	void moveBox(double dX = 0, double dY = 0);
};
#endif
\end{lstlisting}
\scriptsize{Figure 6 Header of Circle}\newline
\newline
\newline
In the header file the declaration of the private and the public members of the Circle class takes place.\newline
The private members are one double with the name 'radius'.
The public members of the class Circle are the default constructor initialized with the constructor of Form and intialize the x and y coordinates of box.\newline 
Then we overloaded the Circle constructor with the parameter 'rad' and initialize radius with rad.\newline
Also we need a move method with the arguments 'dX' and 'dY', a setUpBox method and a private moveBox method with the arguments 'dX' and 'dY.
%=============================================================================
\subsection{Form Headerfile}
%=============================================================================
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
#ifndef _FORM_H_
#define _FORM_H_

#include "Box.h"

class Form {
private:
	double xCenter, yCenter;  
protected:	
	Box box; 
	
public:
	Form();
	void move(double dX, double dY);

	//how to get const ref???
	Box &getBoxRef();
};
#endif
\end{lstlisting}

\scriptsize{Figure 7 Header of Form}\newline
\newline
\newline
In the header file the declaration of the private and the public members of the Form class takes place.\newline
The private members are two double with the name 'xCenter' and 'yCenter'.
The protected member is a Object Box with the name 'box'.
The public members of the class Form are the default constructor.\newline 
Also we need a move method with the arguments 'dX' and 'dY' and a method getBoxRef that returns a reference to the attribute Box.\newline
\newline
%=============================================================================
\subsection{Rectangle Headerfile}
%=============================================================================
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
#ifndef _RECTANGLE_H_
#define _RECTANGLE_H_

#include "Form.h"

class Rectangle: public Form {
private:
	double width, height; 

public:
	Rectangle();
	Rectangle(double h, double w);
	//MOVE FOR RECT
	void move(double dX, double dY);
	void setUpBox();
private:
	void moveBox(double dX = 0, double dY = 0);
	
};
#endif
\end{lstlisting}
\scriptsize{Figure 8 Header of Rectangle}\newline
\newline
\newline
In the header file the declaration of the private and the public members of the Form class takes place.\newline
The private members are two double with the name 'xCenter' and 'yCenter'.
The protected member is a Object Box with the name 'box'.
The public members of the class Form are the default constructor.\newline 
Also we need a move method with the arguments 'dX' and 'dY' and a method getBoxRef that returns a reference to the attribute Box.\newline
\newline
%=============================================================================
\subsection{Box Class}
%=============================================================================

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
#include "Box.h"
#include <iostream>
#include <algorithm>

using namespace std;

Box::Box() : xMin(0.0), xMax(0.0), yMin(0.0), yMax(0.0) {

}

double Box::getXMin() const {
	return xMin;
}

void Box::setXMax(double val) {
	this->xMax = val;
}

double Box::getXMax() const {
	return xMax;
}

void Box::setXMin(double val) {
	this->xMin = val; 
}

double Box::getYMin() const {
	return yMin;
}

void Box::setYMin(double val) {
	this->yMin = val;
}

double Box::getYMax() const {
	return yMax;
}

void Box::setYMax(double val) {
	this->yMax = val; 
}

void Box::print() const {
	cout << "xMax: " << xMax << endl; 
	cout << "xMin: " << xMin << endl;
	cout << "yMax: " << yMax << endl;
	cout << "yMin: " << yMin << endl;
}

Box operator+(Box left, Box right) {
	Box newLeft, newRight;
	if (left.getXMax() > right.getXMax()) {
		newLeft = right;
		newRight = left;
	} else {
		newLeft = left;
		newRight = right;
	}

	Box result; 

	//check if the boxes collide
	if (right.getXMin() < left.getXMax() && right.getYMin() < left.getYMax()) {
		result.setXMin(min(newLeft.getXMin(), newRight.getXMin()));
		result.setXMax(max(newLeft.getXMax(), newRight.getXMax()));
		result.setYMin(min(newLeft.getYMin(), newRight.getYMin()));
		result.setYMax(max(newLeft.getYMax(), newRight.getYMax()));
		return result;
	} else {
		cout << "The boxes of these two objects don't collide." << '\n';
	}
	 
}
\end{lstlisting}
\scriptsize{Figure 9 Box Class}\newline
\newline
\newline
In the Box class we implemented getter and setter Methods. Also we implemented the print method to show the Min and Max coordinate. Then we overload the  operator$+$ method.
%=============================================================================
\subsection{Circle Class}
%=============================================================================
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
#include "Circle.h"

Circle::Circle() : radius(0.0) {
	Form();
	this->box.setXMax(0.0);
	this->box.setXMin(0.0);
	this->box.setYMax(0.0);
	this->box.setYMin(0.0);
}

Circle::Circle(double rad) : radius(rad) {

}

void Circle::setUpBox() {
	this->box.setXMax(this->radius);
	this->box.setXMin(-this->radius);
	this->box.setYMax(this->radius);
	this->box.setYMin(-this->radius);
}

void Circle::move(double dX, double dY) {
	Form::move(dX, dY);
	moveBox(dX, dY);
}

void Circle::moveBox(double dX, double dY) {
	this->box.setXMax(box.getXMax() + dX);
	this->box.setXMin(box.getXMin() + dX);
	this->box.setYMax(box.getYMax() + dY);
	this->box.setYMin(box.getYMin() + dY);
}

\end{lstlisting}
\scriptsize{Figure 10 Circle Class}\newline
\newline
\newline


%=============================================================================
\subsection{Rectangle Class}
%=============================================================================
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
#include "Rectangle.h"

Rectangle::Rectangle() : width(0.0), height(0.0) {
	Form();
	this->box.setXMax(0.0);
	this->box.setXMin(0.0);
	this->box.setYMax(0.0);
	this->box.setYMin(0.0);
}

Rectangle::Rectangle(double h, double w) : width(w), height(h) {

}

void Rectangle::move(double dX, double dY)
{
	Form::move(dX, dY);
	moveBox(dX, dY);
}

void Rectangle::moveBox(double dX, double dY) {
	this->box.setXMax(box.getXMax()+dX);
	this->box.setXMin(box.getXMin()+dX);
	this->box.setYMax(box.getYMax()+dY);
	this->box.setYMin(box.getYMin()+dY);
}

void Rectangle::setUpBox() {
	this->box.setXMax(width / 2);
	this->box.setXMin(-width / 2);
	this->box.setYMax(height / 2);
	this->box.setYMin(-height / 2);
}
\end{lstlisting}
\scriptsize{Figure 11 Rectangle Class}\newline
\newline
\newline
%=============================================================================
\subsection{Main Class}
%=============================================================================
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, numbers=left, stepnumber=1, numberstyle = \normalsize]
#include <iostream>
#include <string>
#include "Circle.h"
#include "Rectangle.h"

using namespace std; 

//checks if the user typed 'circle', returns bool
bool inputIsCircle(string);

//checks if the user typed 'rectangle', returns bool
bool inputIsRect(string);

//asks for needed values and calls circle constructor
Circle* circleCreator(bool isTrue);

//asks for needed values and calls rectangle constructor
Rectangle* rectCreator(bool isTrue);
Box addBoxes(Circle* c1, Circle* c2, Rectangle* r1, Rectangle* r2); 

int main() {

	//arguments for move(...) function
	double movX, movY;

	string prompt = "";

	std::cout << "_______________________________________" << endl; 

	Circle *circle1 = NULL;
	Rectangle *rect1 = NULL;

	cout << "Enter first form (rectangle or circle): ";
	cin >> prompt;

	if (inputIsCircle(prompt)) {
		circle1 = circleCreator(inputIsCircle(prompt));
		circle1->getBoxRef().print();

		cout << "Move Circle in X direction for: ";
		cin >> movX;
		cout << "Move Circle in Y direction for: ";
		cin >> movY;

		circle1->move(movX, movY);
		cout << "After Move is called: " << endl;
		circle1->getBoxRef().print();
	} else if (inputIsRect(prompt))	{
		rect1 = rectCreator(inputIsRect(prompt));
		rect1->getBoxRef().print();

		cout << "Move Rectangle in X direction for: ";
		cin >> movX;
		cout << "Move Rectangle in Y direction for: ";
		cin >> movY;

		rect1->move(movX, movY);
		cout << "After Move is called: " << endl;
		rect1->getBoxRef().print();
	}

	Circle *circle2 = NULL;
	Rectangle *rect2 = NULL;
	cout << "Enter second form (rectangle or circle): ";
	cin >> prompt;
	if (inputIsCircle(prompt)) {
		circle2 = circleCreator(inputIsCircle(prompt));
		circle2->getBoxRef().print();

		cout << "Move Circle in X direction for: ";
		cin >> movX;
		cout << "Move Circle in Y direction for: ";
		cin >> movY;

		circle2->move(movX, movY);
		cout << "After Move is called: " << endl;
		circle2->getBoxRef().print();
	} else if (inputIsRect(prompt)) {
		rect2 = rectCreator(inputIsRect(prompt));
		rect2->getBoxRef().print();

		cout << "Move Rectangle in X direction for: ";
		cin >> movX;
		cout << "Move Rectangle in Y direction for: ";
		cin >> movY;

		rect2->move(movX, movY);
		cout << "After Move is called: " << endl;
		rect2->getBoxRef().print();
	}

	//ADD BOUNDING BOXES AND PRODUCE NEW ONE AS SUM
	Box boundingBox;

	cout << "Bounding Box: " << endl;
	boundingBox = addBoxes(circle1, circle2, rect1, rect2);
	if (!(boundingBox.getXMax() == 0.0 && boundingBox.getXMin() == 0.0 && boundingBox.getYMin() == 0.0 && boundingBox.getYMax() == 0.0)) {
		boundingBox.print();
	}

	cout << "_______________________________________" << endl;

	delete circle1, rect1, circle2, rect2;

	return 0; 
}

Box addBoxes(Circle* c1, Circle* c2, Rectangle* r1, Rectangle* r2) {

	Box result;
	if (c1 == NULL && c2 == NULL) {
		result = r1->getBoxRef() + r2->getBoxRef();
		return result;
	} else if (c1 == NULL && r2 == NULL) {
		result = r1->getBoxRef()+ c2->getBoxRef();
		return result;
	} else if (r1 == NULL && c2 == NULL) {
		result = c1->getBoxRef()+ r2->getBoxRef();
		return result;
	} else if (r1 == NULL && r2 == NULL) {
		result = c1->getBoxRef() + c2->getBoxRef();
		return result;
	}

	return result;
}

bool inputIsCircle(string prompt) {
	string circle = "circle";
	bool result = false; 
	if (prompt.compare(circle) == 0) {
		result = true;
	} else {
		return result; 
	}
	return result;
}

bool inputIsRect(string prompt) {
	string rect = "rectangle";
	bool result = false;
	if (prompt.compare(rect) == 0) {
		result = true; 
	} else {
		return result;
	}

	return result;
}

Circle* circleCreator(bool isTrue) {
	if (isTrue) {
		double rad;

		cout << "Enter radius: ";
		cin >> rad;
		Circle *circle = new Circle(rad);
		circle->setUpBox();
		return circle;
	} else {
		return NULL; 
	}
}

Rectangle* rectCreator(bool isTrue) {
	if (isTrue) {
		double h, w;
		cout << "Enter height: ";
		cin >> h;
		cout << "Enter width: ";
		cin >> w;
		Rectangle *rect = new Rectangle(h, w);
		rect->setUpBox();
		return rect; 
	} else {
		return NULL;
	}
}
\end{lstlisting}
\scriptsize{Figure 12 Main Class}



%=============================================================================
\section{Foundations}
%=============================================================================



%-----------------------------------------------------------------------------
%\subsection{}
%-----------------------------------------------------------------------------



%-----------------------------------------------------------------------------
%\subsection{}
%-----------------------------------------------------------------------------

%-----------------------------------------------------------------------------
%\subsection{}
%-----------------------------------------------------------------------------


%=============================================================================
%\section{}
%=============================================================================



%-----------------------------------------------------------------------------
%\subsection{}
%-----------------------------------------------------------------------------


%=============================================================================
%\section{}
%=============================================================================



%=============================================================================
\section{Conclusion}
%=============================================================================


\end{document}

\newpage

